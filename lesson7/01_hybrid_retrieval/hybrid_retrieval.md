# 教程：混合检索（BM25 + 向量）与重排序示例

## 学习目标
- 理解 BM25 与向量检索各自的优势与局限。
- 掌握得分归一化、权重融合以及再排序的实现思路。
- 通过示例语料观察混合检索对召回率与精确性的影响。

## 背景原理
BM25 基于词项频率与逆文档频率，适合精确匹配；向量检索通过语义嵌入捕捉语义相似性。混合检索通常包含：
1. 分别计算 BM25 与向量得分。
2. 对得分进行归一化（如 min-max），以便融合。
3. 按权重加权求和，得到综合排名。
4. 可选地利用 reranker 根据语义相似度再次排序。

## 代码结构解析
- `BM25Index`：自实现倒排索引，清晰展示 BM25 公式细节。
- `encode_embedding` / `cosine_similarity`：模拟语义向量编码与余弦计算。
- `HybridRetriever.retrieve`：融合 BM25 与向量得分，并调用 `rerank`。
- `normalize_scores`：防止单一检索方式分布差异过大。
- `prepare_corpus` 与 `demo`：构造示例语料并演示检索流程。

## 实践步骤
1. 修改 `raw_texts` 为真实知识库片段，观察混合检索效果。
2. 调整 `weight_bm25` 与 `weight_vector`，讨论权重对排序的影响。
3. 扩展 `rerank`，接入交叉编码器（cross-encoder）获取更准确的最终排名。
4. 记录不同配置下的命中率/召回率，为生产系统调参提供依据。

## 拓展问题
- 如何将 BM25 与向量检索结果合并后再进行学习排序（learning to rank）？
- 混合检索在长尾问题下表现如何，需要如何调整分块或索引？
- 可否引入业务规则（如客户 VIP 优先级）融入最终得分？
